{"version":3,"file":"index.js","sources":["../src/diffDOM/dom/fromVirtual.js","../src/diffDOM/dom/apply.js","../src/diffDOM/dom/undo.js","../src/diffDOM/virtual/helpers.js","../src/diffDOM/virtual/apply.js","../src/diffDOM/virtual/fromDOM.js","../src/diffDOM/virtual/diff.js","../src/diffDOM/index.js","../src/TraceLogger.js"],"sourcesContent":["export function objToNode(objNode, insideSvg, options) {\n    let node\n    if (objNode.nodeName === '#text') {\n        node = options.document.createTextNode(objNode.data)\n\n    } else if (objNode.nodeName === '#comment') {\n        node = options.document.createComment(objNode.data)\n    } else {\n        if (objNode.nodeName === 'svg' || insideSvg) {\n            node = options.document.createElementNS('http://www.w3.org/2000/svg', objNode.nodeName)\n            insideSvg = true\n        } else {\n            node = options.document.createElement(objNode.nodeName)\n        }\n        if (objNode.attributes) {\n            Object.entries(objNode.attributes).forEach(([key, value]) => node.setAttribute(key, value))\n        }\n        if (objNode.childNodes) {\n            objNode.childNodes.forEach(childNode => node.appendChild(objToNode(childNode, insideSvg, options)))\n        }\n        if (options.valueDiffing) {\n            if (objNode.value) {\n                node.value = objNode.value\n            }\n            if (objNode.checked) {\n                node.checked = objNode.checked\n            }\n            if (objNode.selected) {\n                node.selected = objNode.selected\n            }\n        }\n    }\n    return node\n}\n","import {objToNode} from \"./fromVirtual\"\n\n// ===== Apply a diff =====\n\nfunction getFromRoute(node, route) {\n    route = route.slice()\n    while (route.length > 0) {\n        if (!node.childNodes) {\n            return false\n        }\n        const c = route.splice(0, 1)[0]\n        node = node.childNodes[c]\n    }\n    return node\n}\n\nexport function applyDiff(\n        tree,\n        diff,\n        options // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n    ) {\n    let node = getFromRoute(tree, diff[options._const.route])\n    let newNode\n    let reference\n    let route\n    let nodeArray\n    let c\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node\n    }\n\n    if (options.preDiffApply(info)) {\n        return true\n    }\n\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            if (!node || !node.setAttribute) {\n                return false\n            }\n            node.setAttribute(diff[options._const.name], diff[options._const.value])\n            break\n        case options._const.modifyAttribute:\n            if (!node || !node.setAttribute) {\n                return false\n            }\n            node.setAttribute(diff[options._const.name], diff[options._const.newValue])\n            if (node.nodeName === 'INPUT' && diff[options._const.name] === 'value') {\n                node.value = diff[options._const.oldValue]\n            }\n            break\n        case options._const.removeAttribute:\n            if (!node || !node.removeAttribute) {\n                return false\n            }\n            node.removeAttribute(diff[options._const.name])\n            break\n        case options._const.modifyTextElement:\n            if (!node || node.nodeType !== 3) {\n                return false\n            }\n            options.textDiff(node, node.data, diff[options._const.oldValue], diff[options._const.newValue])\n            break\n        case options._const.modifyValue:\n            if (!node || typeof node.value === 'undefined') {\n                return false\n            }\n            node.value = diff[options._const.newValue]\n            break\n        case options._const.modifyComment:\n            if (!node || typeof node.data === 'undefined') {\n                return false\n            }\n            options.textDiff(node, node.data, diff[options._const.oldValue], diff[options._const.newValue])\n            break\n        case options._const.modifyChecked:\n            if (!node || typeof node.checked === 'undefined') {\n                return false\n            }\n            node.checked = diff[options._const.newValue]\n            break\n        case options._const.modifySelected:\n            if (!node || typeof node.selected === 'undefined') {\n                return false\n            }\n            node.selected = diff[options._const.newValue]\n            break\n        case options._const.replaceElement:\n            node.parentNode.replaceChild(\n                objToNode(\n                    diff[options._const.newValue],\n                    node.namespaceURI === 'http://www.w3.org/2000/svg',\n                    options\n                ),\n                node\n            )\n            break\n        case options._const.relocateGroup:\n            nodeArray = Array(...new Array(diff.groupLength)).map(() => node.removeChild(node.childNodes[diff[options._const.from]]))\n            nodeArray.forEach((childNode, index) => {\n                if (index === 0) {\n                    reference = node.childNodes[diff[options._const.to]]\n                }\n                node.insertBefore(childNode, reference || null)\n            })\n            break\n        case options._const.removeElement:\n            node.parentNode.removeChild(node)\n            break\n        case options._const.addElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            node = getFromRoute(tree, route)\n            node.insertBefore(\n                objToNode(\n                    diff[options._const.element],\n                    node.namespaceURI === 'http://www.w3.org/2000/svg',\n                    options\n                ),\n                node.childNodes[c] || null\n            )\n            break\n        case options._const.removeTextElement:\n            if (!node || node.nodeType !== 3) {\n                return false\n            }\n            node.parentNode.removeChild(node)\n            break\n        case options._const.addTextElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            newNode = options.document.createTextNode(diff[options._const.value])\n            node = getFromRoute(tree, route)\n            if (!node || !node.childNodes) {\n                return false\n            }\n            node.insertBefore(newNode, node.childNodes[c] || null)\n            break\n        default:\n            console.log('unknown action')\n    }\n\n    // if a new node was created, we might be interested in its\n    // post diff hook\n    info.newNode = newNode\n    options.postDiffApply(info)\n\n    return true\n}\n\nexport function applyDOM(tree, diffs, options) {\n    return diffs.every(diff => applyDiff(tree, diff, options))\n}\n","import {applyDiff} from \"./apply\"\n\n// ===== Undo a diff =====\n\nfunction swap(obj, p1, p2) {\n    const tmp = obj[p1]\n    obj[p1] = obj[p2]\n    obj[p2] = tmp\n}\n\nfunction undoDiff(\n    tree,\n    diff,\n    options // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n) {\n\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            diff[options._const.action] = options._const.removeAttribute\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyAttribute:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeAttribute:\n            diff[options._const.action] = options._const.addAttribute\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyTextElement:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyValue:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyComment:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyChecked:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifySelected:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.replaceElement:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.relocateGroup:\n            swap(diff, options._const.from, options._const.to)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeElement:\n            diff[options._const.action] = options._const.addElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.addElement:\n            diff[options._const.action] = options._const.removeElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeTextElement:\n            diff[options._const.action] = options._const.addTextElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.addTextElement:\n            diff[options._const.action] = options._const.removeTextElement\n            applyDiff(tree, diff, options)\n            break\n        default:\n            console.log('unknown action')\n    }\n\n}\n\nexport function undoDOM(tree, diffs, options) {\n    if (!diffs.length) {\n        diffs = [diffs]\n    }\n    diffs = diffs.slice()\n    diffs.reverse()\n    diffs.forEach(diff => {\n        undoDiff(tree, diff, options)\n    })\n}\n","export class Diff {\n    constructor(options = {}) {\n        Object.entries(options).forEach(([key, value]) => this[key] = value)\n    }\n\n    toString() {\n        return JSON.stringify(this)\n    }\n\n    setValue(aKey, aValue) {\n        this[aKey] = aValue\n        return this\n    }\n}\n\nfunction elementDescriptors(el) {\n    const output = []\n    if (el.nodeName !== '#text' && el.nodeName !== '#comment') {\n        output.push(el.nodeName)\n        if (el.attributes) {\n            if (el.attributes['class']) {\n                output.push(`${el.nodeName}.${el.attributes['class'].replace(/ /g, '.')}`)\n            }\n            if (el.attributes.id) {\n                output.push(`${el.nodeName}#${el.attributes.id}`)\n            }\n        }\n\n    }\n    return output\n}\n\nfunction findUniqueDescriptors(li) {\n    const uniqueDescriptors = {}\n    const duplicateDescriptors = {}\n\n    li.forEach(node => {\n        elementDescriptors(node).forEach(descriptor => {\n            const inUnique = descriptor in uniqueDescriptors\n            const inDupes = descriptor in duplicateDescriptors\n            if (!inUnique && !inDupes) {\n                uniqueDescriptors[descriptor] = true\n            } else if (inUnique) {\n                delete uniqueDescriptors[descriptor]\n                duplicateDescriptors[descriptor] = true\n            }\n        })\n    })\n\n    return uniqueDescriptors\n}\n\nfunction uniqueInBoth(l1, l2) {\n    const l1Unique = findUniqueDescriptors(l1)\n    const l2Unique = findUniqueDescriptors(l2)\n    const inBoth = {}\n\n    Object.keys(l1Unique).forEach(key => {\n        if (l2Unique[key]) {\n            inBoth[key] = true\n        }\n    })\n\n    return inBoth\n}\n\nexport function removeDone(tree) {\n    delete tree.outerDone\n    delete tree.innerDone\n    delete tree.valueDone\n    if (tree.childNodes) {\n        return tree.childNodes.every(removeDone)\n    } else {\n        return true\n    }\n}\n\nexport function isEqual(e1, e2) {\n    if (!['nodeName', 'value', 'checked', 'selected', 'data'].every(element => {\n            if (e1[element] !== e2[element]) {\n                return false\n            }\n            return true\n        })) {\n        return false\n    }\n\n    if (Boolean(e1.attributes) !== Boolean(e2.attributes)) {\n        return false\n    }\n\n    if (Boolean(e1.childNodes) !== Boolean(e2.childNodes)) {\n        return false\n    }\n    if (e1.attributes) {\n        const e1Attributes = Object.keys(e1.attributes)\n        const e2Attributes = Object.keys(e2.attributes)\n\n        if (e1Attributes.length !== e2Attributes.length) {\n            return false\n        }\n        if (!e1Attributes.every(attribute => {\n                if (e1.attributes[attribute] !== e2.attributes[attribute]) {\n                    return false\n                }\n                return true\n            })) {\n            return false\n        }\n    }\n    if (e1.childNodes) {\n        if (e1.childNodes.length !== e2.childNodes.length) {\n            return false\n        }\n        if (!e1.childNodes.every((childNode, index) => isEqual(childNode, e2.childNodes[index]))) {\n\n            return false\n        }\n\n    }\n\n    return true\n}\n\n\nexport function roughlyEqual(e1, e2, uniqueDescriptors, sameSiblings, preventRecursion) {\n\n    if (!e1 || !e2) {\n        return false\n    }\n\n    if (e1.nodeName !== e2.nodeName) {\n        return false\n    }\n\n    if (e1.nodeName === '#text') {\n        // Note that we initially don't care what the text content of a node is,\n        // the mere fact that it's the same tag and \"has text\" means it's roughly\n        // equal, and then we can find out the true text difference later.\n        return preventRecursion ? true : e1.data === e2.data\n    }\n\n\n    if (e1.nodeName in uniqueDescriptors) {\n        return true\n    }\n\n    if (e1.attributes && e2.attributes) {\n\n        if (e1.attributes.id) {\n            if (e1.attributes.id !== e2.attributes.id) {\n                return false\n            } else {\n                const idDescriptor = `${e1.nodeName}#${e1.attributes.id}`\n                if (idDescriptor in uniqueDescriptors) {\n                    return true\n                }\n            }\n        }\n        if (e1.attributes['class'] && e1.attributes['class'] === e2.attributes['class']) {\n            const classDescriptor = `${e1.nodeName}.${e1.attributes['class'].replace(/ /g, '.')}`\n            if (classDescriptor in uniqueDescriptors) {\n                return true\n            }\n        }\n    }\n\n    if (sameSiblings) {\n        return true\n    }\n\n    const nodeList1 = e1.childNodes ? e1.childNodes.slice().reverse() : []\n    const nodeList2 = e2.childNodes ? e2.childNodes.slice().reverse() : []\n\n    if (nodeList1.length !== nodeList2.length) {\n        return false\n    }\n\n    if (preventRecursion) {\n        return nodeList1.every((element, index) => element.nodeName === nodeList2[index].nodeName)\n    } else {\n        // note: we only allow one level of recursion at any depth. If 'preventRecursion'\n        // was not set, we must explicitly force it to true for child iterations.\n        const childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2)\n        return nodeList1.every((element, index) => roughlyEqual(element, nodeList2[index], childUniqueDescriptors, true, true))\n    }\n}\n\n\nexport function cloneObj(obj) { //  TODO: Do we really need to clone here? Is it not enough to just return the original object?\n    return JSON.parse(JSON.stringify(obj))\n}\n/**\n * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\n */\nfunction findCommonSubsets(c1, c2, marked1, marked2) {\n    let lcsSize = 0\n    let index = []\n    const c1Length = c1.length\n    const c2Length = c2.length\n\n    const // set up the matching table\n        matches = Array(...new Array(c1Length + 1)).map(() => [])\n\n    const uniqueDescriptors = uniqueInBoth(c1, c2)\n\n    let // If all of the elements are the same tag, id and class, then we can\n        // consider them roughly the same even if they have a different number of\n        // children. This will reduce removing and re-adding similar elements.\n        subsetsSame = c1Length === c2Length\n\n    if (subsetsSame) {\n\n        c1.some((element, i) => {\n            const c1Desc = elementDescriptors(element)\n            const c2Desc = elementDescriptors(c2[i])\n            if (c1Desc.length !== c2Desc.length) {\n                subsetsSame = false\n                return true\n            }\n            c1Desc.some((description, i) => {\n                if (description !== c2Desc[i]) {\n                    subsetsSame = false\n                    return true\n                }\n            })\n            if (!subsetsSame) {\n                return true\n            }\n        })\n    }\n\n    // fill the matches with distance values\n    for (let c1Index = 0; c1Index < c1Length; c1Index++) {\n        const c1Element = c1[c1Index]\n        for (let c2Index = 0; c2Index < c2Length; c2Index++) {\n            const c2Element = c2[c2Index]\n            if (!marked1[c1Index] && !marked2[c2Index] && roughlyEqual(c1Element, c2Element, uniqueDescriptors, subsetsSame)) {\n                matches[c1Index + 1][c2Index + 1] = (matches[c1Index][c2Index] ? matches[c1Index][c2Index] + 1 : 1)\n                if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {\n                    lcsSize = matches[c1Index + 1][c2Index + 1]\n                    index = [c1Index + 1, c2Index + 1]\n                }\n            } else {\n                matches[c1Index + 1][c2Index + 1] = 0\n            }\n        }\n    }\n\n    if (lcsSize === 0) {\n        return false\n    }\n\n    return {\n        oldValue: index[0] - lcsSize,\n        newValue: index[1] - lcsSize,\n        length: lcsSize\n    }\n}\n\n/**\n * This should really be a predefined function in Array...\n */\nfunction makeArray(n, v) {\n    return Array(...new Array(n)).map(() => v)\n}\n\n/**\n * Generate arrays that indicate which node belongs to which subset,\n * or whether it's actually an orphan node, existing in only one\n * of the two trees, rather than somewhere in both.\n *\n * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\n * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\n * The second longest is \"<img>\" (length 1), so it will be group 1.\n * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\n *\n * If an element is not part of any group, it will stay being 'true', which\n * is the initial value. For example:\n * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\n *\n * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\n * therefore be marked by \"true\". The remaining parts are parts of the\n * groups 0 and 1:\n * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\n *\n */\nexport function getGapInformation(t1, t2, stable) {\n    const gaps1 = t1.childNodes ? makeArray(t1.childNodes.length, true) : []\n    const gaps2 = t2.childNodes ? makeArray(t2.childNodes.length, true) : []\n    let group = 0\n\n    // give elements from the same subset the same group number\n    stable.forEach(subset => {\n        const endOld = subset.oldValue + subset.length\n        const endNew = subset.newValue + subset.length\n\n        for (let j = subset.oldValue; j < endOld; j += 1) {\n            gaps1[j] = group\n        }\n        for (let j = subset.newValue; j < endNew; j += 1) {\n            gaps2[j] = group\n        }\n        group += 1\n    })\n\n    return {\n        gaps1,\n        gaps2\n    }\n}\n\n/**\n * Find all matching subsets, based on immediate child differences only.\n */\nexport function markSubTrees(oldTree, newTree) {\n    // note: the child lists are views, and so update as we update old/newTree\n    const oldChildren = oldTree.childNodes ? oldTree.childNodes : []\n\n    const newChildren = newTree.childNodes ? newTree.childNodes : []\n    const marked1 = makeArray(oldChildren.length, false)\n    const marked2 = makeArray(newChildren.length, false)\n    const subsets = []\n    let subset = true\n\n    const returnIndex = function() {\n        return arguments[1]\n    }\n\n    const markBoth = i => {\n        marked1[subset.oldValue + i] = true\n        marked2[subset.newValue + i] = true\n    }\n\n    while (subset) {\n        subset = findCommonSubsets(oldChildren, newChildren, marked1, marked2)\n        if (subset) {\n            subsets.push(subset)\n            const subsetArray = Array(...new Array(subset.length)).map(returnIndex)\n            subsetArray.forEach(item => markBoth(item))\n        }\n    }\n\n    oldTree.subsets = subsets\n    oldTree.subsetsAge = 100\n    return subsets\n}\n\nexport class DiffTracker {\n    constructor() {\n        this.list = []\n    }\n\n    add(diffs) {\n        this.list.push(...diffs)\n    }\n    forEach(fn) {\n        this.list.forEach(li => fn(li))\n    }\n\n}\n","import {cloneObj} from \"./helpers\"\n\n// ===== Apply a virtual diff =====\n\nfunction getFromVirtualRoute(tree, route) {\n    let node = tree\n    let parentNode\n    let nodeIndex\n\n    route = route.slice()\n    while (route.length > 0) {\n        if (!node.childNodes) {\n            return false\n        }\n        nodeIndex = route.splice(0, 1)[0]\n        parentNode = node\n        node = node.childNodes[nodeIndex]\n    }\n    return {\n        node,\n        parentNode,\n        nodeIndex\n    }\n}\n\nfunction applyVirtualDiff(\n        tree,\n        diff,\n        options // {preDiffApply, postDiffApply, _const}\n    ) {\n    const routeInfo = getFromVirtualRoute(tree, diff[options._const.route])\n    let node = routeInfo.node\n    const parentNode = routeInfo.parentNode\n    const nodeIndex = routeInfo.nodeIndex\n    const newSubsets = []\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node\n    }\n\n    if (options.preDiffApply(info)) {\n        return true\n    }\n\n    let newNode\n    let nodeArray\n    let route\n    let c\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            if (!node.attributes) {\n                node.attributes = {}\n            }\n\n            node.attributes[diff[options._const.name]] = diff[options._const.value]\n\n            if (diff[options._const.name] === 'checked') {\n                node.checked = true\n            } else if (diff[options._const.name] === 'selected') {\n                node.selected = true\n            } else if (node.nodeName === 'INPUT' && diff[options._const.name] === 'value') {\n                node.value = diff[options._const.value]\n            }\n\n            break\n        case options._const.modifyAttribute:\n            node.attributes[diff[options._const.name]] = diff[options._const.newValue]\n            break\n        case options._const.removeAttribute:\n\n            delete node.attributes[diff[options._const.name]]\n\n            if (Object.keys(node.attributes).length === 0) {\n                delete node.attributes\n            }\n\n            if (diff[options._const.name] === 'checked') {\n                node.checked = false\n            } else if (diff[options._const.name] === 'selected') {\n                delete node.selected\n            } else if (node.nodeName === 'INPUT' && diff[options._const.name] === 'value') {\n                delete node.value\n            }\n\n            break\n        case options._const.modifyTextElement:\n            node.data = diff[options._const.newValue]\n            break\n        case options._const.modifyValue:\n            node.value = diff[options._const.newValue]\n            break\n        case options._const.modifyComment:\n            node.data = diff[options._const.newValue]\n            break\n        case options._const.modifyChecked:\n            node.checked = diff[options._const.newValue]\n            break\n        case options._const.modifySelected:\n            node.selected = diff[options._const.newValue]\n            break\n        case options._const.replaceElement:\n            newNode = cloneObj(diff[options._const.newValue])\n            newNode.outerDone = true\n            newNode.innerDone = true\n            newNode.valueDone = true\n            parentNode.childNodes[nodeIndex] = newNode\n            break\n        case options._const.relocateGroup:\n            nodeArray = node.childNodes.splice(diff[options._const.from], diff.groupLength).reverse()\n            nodeArray.forEach(movedNode => node.childNodes.splice(diff[options._const.to], 0, movedNode))\n            if (node.subsets) {\n                node.subsets.forEach(map => {\n                    if (diff[options._const.from] < diff[options._const.to] && map.oldValue <= diff[options._const.to] && map.oldValue > diff[options._const.from]) {\n                        map.oldValue -= diff.groupLength\n                        const splitLength = map.oldValue + map.length - diff[options._const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue: diff[options._const.to] + diff.groupLength,\n                                newValue: map.newValue + map.length - splitLength,\n                                length: splitLength\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (diff[options._const.from] > diff[options._const.to] && map.oldValue > diff[options._const.to] && map.oldValue < diff[options._const.from]) {\n                        map.oldValue += diff.groupLength\n                        const splitLength = map.oldValue + map.length - diff[options._const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue: diff[options._const.to] + diff.groupLength,\n                                newValue: map.newValue + map.length - splitLength,\n                                length: splitLength\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (map.oldValue === diff[options._const.from]) {\n                        map.oldValue = diff[options._const.to]\n                    }\n                })\n            }\n\n            break\n        case options._const.removeElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach(map => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue: map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length: map.length - nodeIndex + map.oldValue - 1\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case options._const.addElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            node = getFromVirtualRoute(tree, route).node\n            newNode = cloneObj(diff[options._const.element])\n            newNode.outerDone = true\n            newNode.innerDone = true\n            newNode.valueDone = true\n\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.subsets) {\n                node.subsets.forEach(map => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    } else if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        case options._const.removeTextElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.nodeName === 'TEXTAREA') {\n                delete parentNode.value\n            }\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach(map => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue: map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length: map.length - nodeIndex + map.oldValue - 1\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case options._const.addTextElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            newNode = {}\n            newNode.nodeName = '#text'\n            newNode.data = diff[options._const.value]\n            node = getFromVirtualRoute(tree, route).node\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.nodeName === 'TEXTAREA') {\n                node.value = diff[options._const.newValue]\n            }\n            if (node.subsets) {\n                node.subsets.forEach(map => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    }\n                    if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        default:\n            console.log('unknown action')\n    }\n\n    if (node.subsets) {\n        node.subsets = node.subsets.filter(map => !map.delete && map.oldValue !== map.newValue)\n        if (newSubsets.length) {\n            node.subsets = node.subsets.concat(newSubsets)\n        }\n    }\n\n    // capture newNode for the callback\n    info.newNode = newNode\n    options.postDiffApply(info)\n\n    return\n}\n\nexport function applyVirtual(tree, diffs, options) {\n    diffs.forEach(diff => {\n        applyVirtualDiff(tree, diff, options)\n    })\n    return true\n}\n","export function nodeToObj(aNode, options) {\n    const objNode = {}\n    objNode.nodeName = aNode.nodeName\n    if (objNode.nodeName === '#text' || objNode.nodeName === '#comment') {\n        objNode.data = aNode.data\n    } else {\n        if (aNode.attributes && aNode.attributes.length > 0) {\n            objNode.attributes = {}\n            const nodeArray = Array.prototype.slice.call(aNode.attributes)\n            nodeArray.forEach(attribute => objNode.attributes[attribute.name] = attribute.value)\n        }\n        if (objNode.nodeName === 'TEXTAREA') {\n            objNode.value = aNode.value\n        } else if (aNode.childNodes && aNode.childNodes.length > 0) {\n            objNode.childNodes = []\n            const nodeArray = Array.prototype.slice.call(aNode.childNodes)\n            nodeArray.forEach(childNode => objNode.childNodes.push(nodeToObj(childNode, options)))\n        }\n        if (options.valueDiffing) {\n            if (aNode.checked !== undefined && aNode.type && ['radio', 'checkbox'].includes(aNode.type.toLowerCase())) {\n                objNode.checked = aNode.checked\n            } else if (aNode.value !== undefined) {\n                objNode.value = aNode.value\n            }\n            if (aNode.selected !== undefined) {\n                objNode.selected = aNode.selected\n            }\n        }\n    }\n    return objNode\n}\n","import {Diff, DiffTracker, cloneObj, getGapInformation, isEqual, markSubTrees, removeDone, roughlyEqual} from \"./helpers\"\nimport {applyVirtual} from \"./apply\"\nimport {nodeToObj} from \"./fromDOM\"\n\n// ===== Create a diff =====\n\nexport class DiffFinder {\n    constructor(t1Node, t2Node, options) {\n        this.options = options\n        this.t1 = nodeToObj(t1Node, this.options)\n        this.t2 = nodeToObj(t2Node, this.options)\n\n        this.diffcount = 0\n        this.foundAll = false\n\n        if (this.debug) {\n            this.t1Orig = nodeToObj(t1Node, this.options)\n            this.t2Orig = nodeToObj(t2Node, this.options)\n        }\n\n        this.tracker = new DiffTracker()\n    }\n\n    init() {\n        return this.findDiffs(this.t1, this.t2)\n    }\n\n    findDiffs(t1, t2) {\n        let diffs\n        do {\n            if (this.options.debug) {\n                this.diffcount += 1\n                if (this.diffcount > this.options.diffcap) {\n                    window.diffError = [this.t1Orig, this.t2Orig]\n                    throw new Error(`surpassed diffcap:${JSON.stringify(this.t1Orig)} -> ${JSON.stringify(this.t2Orig)}`)\n                }\n            }\n            diffs = this.findNextDiff(t1, t2, [])\n\n            if (diffs.length === 0) {\n                // Last check if the elements really are the same now.\n                // If not, remove all info about being done and start over.\n                // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\n                if (!isEqual(t1, t2)) {\n                    if (this.foundAll) {\n                        console.error('Could not find remaining diffs!')\n                        console.log({\n                            t1,\n                            t2\n                        })\n                    } else {\n                        this.foundAll = true\n                        removeDone(t1)\n                        diffs = this.findNextDiff(t1, t2, [])\n                    }\n                }\n            }\n            if (diffs.length > 0) {\n                this.foundAll = false\n                this.tracker.add(diffs)\n                applyVirtual(t1, diffs, this.options)\n            }\n        } while (diffs.length > 0)\n        return this.tracker.list\n    }\n\n    findNextDiff(t1, t2, route) {\n        let diffs\n        let fdiffs\n\n        if (this.options.maxDepth && route.length > this.options.maxDepth) {\n            return []\n        }\n        // outer differences?\n        if (!t1.outerDone) {\n            diffs = this.findOuterDiff(t1, t2, route)\n            if (this.filterOuterDiff) {\n                fdiffs = this.filterOuterDiff(t1, t2, diffs)\n                if (fdiffs) diffs = fdiffs\n            }\n            if (diffs.length > 0) {\n                t1.outerDone = true\n                return diffs\n            } else {\n                t1.outerDone = true\n            }\n        }\n        // inner differences?\n        if (!t1.innerDone) {\n            diffs = this.findInnerDiff(t1, t2, route)\n            if (diffs.length > 0) {\n                return diffs\n            } else {\n                t1.innerDone = true\n            }\n        }\n\n        if (this.options.valueDiffing && !t1.valueDone) {\n            // value differences?\n            diffs = this.findValueDiff(t1, t2, route)\n\n            if (diffs.length > 0) {\n                t1.valueDone = true\n                return diffs\n            } else {\n                t1.valueDone = true\n            }\n        }\n\n        // no differences\n        return []\n    }\n\n    findOuterDiff(t1, t2, route) {\n        const diffs = []\n        let attr\n        let attr1\n        let attr2\n        let attrLength\n        let pos\n        let i\n\n        if (t1.nodeName !== t2.nodeName) {\n            return [new Diff()\n                .setValue(this.options._const.action, this.options._const.replaceElement)\n                .setValue(this.options._const.oldValue, cloneObj(t1))\n                .setValue(this.options._const.newValue, cloneObj(t2))\n                .setValue(this.options._const.route, route)\n            ]\n        }\n\n        if (route.length && this.options.maxChildCount && t1.childNodes && t2.childNodes && t1.childNodes.length > this.options.maxChildCount && t2.childNodes.length > this.options.maxChildCount) {\n            const childNodesLength = t1.childNodes.length < t2.childNodes.length ? t1.childNodes.length : t2.childNodes.length\n            let childDiffCount = 0\n            let j = 0\n            while (childDiffCount < this.options.maxChildDiffCount && j < childNodesLength) {\n                if (!isEqual(t1.childNodes[j], t2.childNodes[j])) {\n                    childDiffCount++\n                }\n                j++\n            }\n            if (childDiffCount === this.options.maxChildDiffCount) {\n                return [new Diff()\n                    .setValue(this.options._const.action, this.options._const.replaceElement)\n                    .setValue(this.options._const.oldValue, cloneObj(t1))\n                    .setValue(this.options._const.newValue, cloneObj(t2))\n                    .setValue(this.options._const.route, route)\n                ]\n            }\n        }\n\n        if (t1.data !== t2.data) {\n            // Comment or text node.\n            if (t1.nodeName === '#text') {\n                return [new Diff()\n                    .setValue(this.options._const.action, this.options._const.modifyTextElement)\n                    .setValue(this.options._const.route, route)\n                    .setValue(this.options._const.oldValue, t1.data)\n                    .setValue(this.options._const.newValue, t2.data)\n                ]\n            } else {\n                return [new Diff()\n                    .setValue(this.options._const.action, this.options._const.modifyComment)\n                    .setValue(this.options._const.route, route)\n                    .setValue(this.options._const.oldValue, t1.data)\n                    .setValue(this.options._const.newValue, t2.data)\n                ]\n            }\n\n        }\n\n\n        attr1 = t1.attributes ? Object.keys(t1.attributes).sort() : []\n        attr2 = t2.attributes ? Object.keys(t2.attributes).sort() : []\n\n        attrLength = attr1.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr1[i]\n            pos = attr2.indexOf(attr)\n            if (pos === -1) {\n                diffs.push(new Diff()\n                    .setValue(this.options._const.action, this.options._const.removeAttribute)\n                    .setValue(this.options._const.route, route)\n                    .setValue(this.options._const.name, attr)\n                    .setValue(this.options._const.value, t1.attributes[attr])\n                )\n            } else {\n                attr2.splice(pos, 1)\n                if (t1.attributes[attr] !== t2.attributes[attr]) {\n                    diffs.push(new Diff()\n                        .setValue(this.options._const.action, this.options._const.modifyAttribute)\n                        .setValue(this.options._const.route, route)\n                        .setValue(this.options._const.name, attr)\n                        .setValue(this.options._const.oldValue, t1.attributes[attr])\n                        .setValue(this.options._const.newValue, t2.attributes[attr])\n                    )\n                }\n            }\n        }\n\n        attrLength = attr2.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr2[i]\n            diffs.push(new Diff()\n                .setValue(this.options._const.action, this.options._const.addAttribute)\n                .setValue(this.options._const.route, route)\n                .setValue(this.options._const.name, attr)\n                .setValue(this.options._const.value, t2.attributes[attr])\n            )\n        }\n\n        return diffs\n    }\n\n    findInnerDiff(t1, t2, route) {\n\n        //var subtrees = (t1.childNodes && t2.childNodes) ?  markSubTrees(t1, t2) : [],\n        const subtrees = t1.subsets && t1.subsetsAge-- ? t1.subsets : (t1.childNodes && t2.childNodes) ? markSubTrees(t1, t2) : []\n\n        const t1ChildNodes = t1.childNodes ? t1.childNodes : []\n        const t2ChildNodes = t2.childNodes ? t2.childNodes : []\n        let childNodesLengthDifference\n        let diffs = []\n        let index = 0\n\n        if (subtrees.length > 0) {\n            /* One or more groups have been identified among the childnodes of t1\n             * and t2.\n             */\n            diffs = this.attemptGroupRelocation(t1, t2, subtrees, route)\n            if (diffs.length > 0) {\n                return diffs\n            }\n        }\n\n        /* 0 or 1 groups of similar child nodes have been found\n         * for t1 and t2. 1 If there is 1, it could be a sign that the\n         * contents are the same. When the number of groups is below 2,\n         * t1 and t2 are made to have the same length and each of the\n         * pairs of child nodes are diffed.\n         */\n\n        const last = Math.max(t1ChildNodes.length, t2ChildNodes.length)\n        if (t1ChildNodes.length !== t2ChildNodes.length) {\n            childNodesLengthDifference = true\n        }\n\n        for (let i = 0; i < last; i += 1) {\n            const e1 = t1ChildNodes[i]\n            const e2 = t2ChildNodes[i]\n\n            if (childNodesLengthDifference) {\n                /* t1 and t2 have different amounts of childNodes. Add\n                 * and remove as necessary to obtain the same length */\n                if (e1 && !e2) {\n                    if (e1.nodeName === '#text') {\n                        diffs.push(new Diff()\n                            .setValue(this.options._const.action, this.options._const.removeTextElement)\n                            .setValue(this.options._const.route, route.concat(index))\n                            .setValue(this.options._const.value, e1.data)\n                        )\n                        index -= 1\n                    } else {\n                        diffs.push(new Diff()\n                            .setValue(this.options._const.action, this.options._const.removeElement)\n                            .setValue(this.options._const.route, route.concat(index))\n                            .setValue(this.options._const.element, cloneObj(e1))\n                        )\n                        index -= 1\n                    }\n\n                } else if (e2 && !e1) {\n                    if (e2.nodeName === '#text') {\n                        diffs.push(new Diff()\n                            .setValue(this.options._const.action, this.options._const.addTextElement)\n                            .setValue(this.options._const.route, route.concat(index))\n                            .setValue(this.options._const.value, e2.data)\n                        )\n                    } else {\n                        diffs.push(new Diff()\n                            .setValue(this.options._const.action, this.options._const.addElement)\n                            .setValue(this.options._const.route, route.concat(index))\n                            .setValue(this.options._const.element, cloneObj(e2))\n                        )\n                    }\n                }\n            }\n            /* We are now guaranteed that childNodes e1 and e2 exist,\n             * and that they can be diffed.\n             */\n            /* Diffs in child nodes should not affect the parent node,\n             * so we let these diffs be submitted together with other\n             * diffs.\n             */\n\n            if (e1 && e2) {\n                diffs = diffs.concat(this.findNextDiff(e1, e2, route.concat(index)))\n            }\n\n            index += 1\n\n        }\n        t1.innerDone = true\n        return diffs\n    }\n\n    attemptGroupRelocation(t1, t2, subtrees, route) {\n        /* Either t1.childNodes and t2.childNodes have the same length, or\n         * there are at least two groups of similar elements can be found.\n         * attempts are made at equalizing t1 with t2. First all initial\n         * elements with no group affiliation (gaps=true) are removed (if\n         * only in t1) or added (if only in t2). Then the creation of a group\n         * relocation diff is attempted.\n         */\n        const gapInformation = getGapInformation(t1, t2, subtrees)\n        const gaps1 = gapInformation.gaps1\n        const gaps2 = gapInformation.gaps2\n        let shortest = Math.min(gaps1.length, gaps2.length)\n        let destinationDifferent\n        let toGroup\n        let group\n        let node\n        let similarNode\n        let testI\n        const diffs = []\n\n\n        for (let index2 = 0, index1 = 0; index2 < shortest; index1 += 1, index2 += 1) {\n            if (gaps1[index2] === true) {\n                node = t1.childNodes[index1]\n                if (node.nodeName === '#text') {\n                    if (t2.childNodes[index2].nodeName === '#text' && node.data !== t2.childNodes[index2].data) {\n                        testI = index1\n                        while (t1.childNodes.length > testI + 1 && t1.childNodes[testI + 1].nodeName === '#text') {\n                            testI += 1\n                            if (t2.childNodes[index2].data === t1.childNodes[testI].data) {\n                                similarNode = true\n                                break\n                            }\n                        }\n                        if (!similarNode) {\n                            diffs.push(new Diff()\n                                .setValue(this.options._const.action, this.options._const.modifyTextElement)\n                                .setValue(this.options._const.route, route.concat(index2))\n                                .setValue(this.options._const.oldValue, node.data)\n                                .setValue(this.options._const.newValue, t2.childNodes[index2].data)\n                            )\n                            return diffs\n                        }\n                    }\n                    diffs.push(new Diff()\n                        .setValue(this.options._const.action, this.options._const.removeTextElement)\n                        .setValue(this.options._const.route, route.concat(index2))\n                        .setValue(this.options._const.value, node.data)\n                    )\n                    gaps1.splice(index2, 1)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index2 -= 1\n                } else {\n                    diffs.push(new Diff()\n                        .setValue(this.options._const.action, this.options._const.removeElement)\n                        .setValue(this.options._const.route, route.concat(index2))\n                        .setValue(this.options._const.element, cloneObj(node))\n                    )\n                    gaps1.splice(index2, 1)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index2 -= 1\n                }\n\n            } else if (gaps2[index2] === true) {\n                node = t2.childNodes[index2]\n                if (node.nodeName === '#text') {\n                    diffs.push(new Diff()\n                        .setValue(this.options._const.action, this.options._const.addTextElement)\n                        .setValue(this.options._const.route, route.concat(index2))\n                        .setValue(this.options._const.value, node.data)\n                    )\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                } else {\n                    diffs.push(new Diff()\n                        .setValue(this.options._const.action, this.options._const.addElement)\n                        .setValue(this.options._const.route, route.concat(index2))\n                        .setValue(this.options._const.element, cloneObj(node))\n                    )\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                }\n\n            } else if (gaps1[index2] !== gaps2[index2]) {\n                if (diffs.length > 0) {\n                    return diffs\n                }\n                // group relocation\n                group = subtrees[gaps1[index2]]\n                toGroup = Math.min(group.newValue, (t1.childNodes.length - group.length))\n                if (toGroup !== group.oldValue) {\n                    // Check whether destination nodes are different than originating ones.\n                    destinationDifferent = false\n                    for (let j = 0; j < group.length; j += 1) {\n                        if (!roughlyEqual(t1.childNodes[toGroup + j], t1.childNodes[group.oldValue + j], [], false, true)) {\n                            destinationDifferent = true\n                        }\n                    }\n                    if (destinationDifferent) {\n                        return [new Diff()\n                            .setValue(this.options._const.action, this.options._const.relocateGroup)\n                            .setValue('groupLength', group.length)\n                            .setValue(this.options._const.from, group.oldValue)\n                            .setValue(this.options._const.to, toGroup)\n                            .setValue(this.options._const.route, route)\n                        ]\n                    }\n                }\n            }\n        }\n        return diffs\n    }\n\n    findValueDiff(t1, t2, route) {\n        // Differences of value. Only useful if the value/selection/checked value\n        // differs from what is represented in the DOM. For example in the case\n        // of filled out forms, etc.\n        const diffs = []\n\n        if (t1.selected !== t2.selected) {\n            diffs.push(new Diff()\n                .setValue(this.options._const.action, this.options._const.modifySelected)\n                .setValue(this.options._const.oldValue, t1.selected)\n                .setValue(this.options._const.newValue, t2.selected)\n                .setValue(this.options._const.route, route)\n            )\n        }\n\n        if ((t1.value || t2.value) && t1.value !== t2.value && t1.nodeName !== 'OPTION') {\n            diffs.push(new Diff()\n                .setValue(this.options._const.action, this.options._const.modifyValue)\n                .setValue(this.options._const.oldValue, t1.value || \"\")\n                .setValue(this.options._const.newValue, t2.value || \"\")\n                .setValue(this.options._const.route, route)\n            )\n        }\n        if (t1.checked !== t2.checked) {\n            diffs.push(new Diff()\n                .setValue(this.options._const.action, this.options._const.modifyChecked)\n                .setValue(this.options._const.oldValue, t1.checked)\n                .setValue(this.options._const.newValue, t2.checked)\n                .setValue(this.options._const.route, route)\n            )\n        }\n\n        return diffs\n    }\n\n}\n","import {applyDOM, undoDOM} from \"./dom/index\"\nimport {DiffFinder} from \"./virtual/index\"\n\nconst DEFAULT_OPTIONS = {\n    debug: false,\n    diffcap: 10, // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\n    maxDepth: false, // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\n    maxChildCount: 50, // False or a numeral. If set to a numeral, does not try to diff the contents of nodes with more children if there are more than maxChildDiffCount differences among child nodes.\n    maxChildDiffCount: 3, // Numeral. See maxChildCount.\n    valueDiffing: true, // Whether to take into consideration the values of forms that differ from auto assigned values (when a user fills out a form).\n    // syntax: textDiff: function (node, currentValue, expectedValue, newValue)\n    textDiff(node, currentValue, expectedValue, newValue) {\n        node.data = newValue\n        return\n    },\n    // empty functions were benchmarked as running faster than both\n    // `f && f()` and `if (f) { f(); }`\n    preVirtualDiffApply() {},\n    postVirtualDiffApply() {},\n    preDiffApply() {},\n    postDiffApply() {},\n    filterOuterDiff: null,\n    compress: false, // Whether to work with compressed diffs\n    _const: false, // object with strings for every change types to be used in diffs.\n    document: window && window.document ? window.document : false\n}\n\n\nexport class DiffDOM {\n    constructor(options = {}) {\n\n        this.options = options\n        // IE11 doesn't have Object.assign and buble doesn't translate object spreaders\n        // by default, so this is the safest way of doing it currently.\n        Object.entries(DEFAULT_OPTIONS).forEach(([key, value]) => {\n            if (!Object.prototype.hasOwnProperty.call(this.options, key)) {\n                this.options[key] = value\n            }\n        })\n\n        if (!this.options._const) {\n            const varNames = [\"addAttribute\", \"modifyAttribute\", \"removeAttribute\",\n                \"modifyTextElement\", \"relocateGroup\", \"removeElement\", \"addElement\",\n                \"removeTextElement\", \"addTextElement\", \"replaceElement\", \"modifyValue\",\n                \"modifyChecked\", \"modifySelected\", \"modifyComment\", \"action\", \"route\",\n                \"oldValue\", \"newValue\", \"element\", \"group\", \"from\", \"to\", \"name\",\n                \"value\", \"data\", \"attributes\", \"nodeName\", \"childNodes\", \"checked\",\n                \"selected\"\n            ]\n            this.options._const = {}\n            if (this.options.compress) {\n                varNames.forEach((varName, index) => this.options._const[varName] = index)\n            } else {\n                varNames.forEach(varName => this.options._const[varName] = varName)\n            }\n        }\n\n        this.DiffFinder = DiffFinder\n\n    }\n\n    apply(tree, diffs) {\n        return applyDOM(tree, diffs, this.options)\n    }\n\n    undo(tree, diffs) {\n        return undoDOM(tree, diffs, this.options)\n    }\n\n    diff(t1Node, t2Node) {\n        const finder = new this.DiffFinder(t1Node, t2Node, this.options)\n        return finder.init()\n    }\n\n}\n","/**\n * Use TraceLogger to figure out function calls inside\n * JS objects by wrapping an object with a TraceLogger\n * instance.\n *\n * Pretty-prints the call trace (using unicode box code)\n * when tracelogger.toString() is called.\n */\n\n/**\n * Wrap an object by calling new TraceLogger(obj)\n *\n * If you're familiar with Python decorators, this\n * does roughly the same thing, adding pre/post\n * call hook logging calls so that you can see\n * what's going on.\n */\nexport class TraceLogger {\n    constructor(obj = {}) {\n        this.pad = \"│   \"\n        this.padding = \"\"\n        this.tick = 1\n        this.messages = []\n        const wrapkey = (obj, key) => {\n            // trace this function\n            const oldfn = obj[key]\n            obj[key] = (...args) => {\n                this.fin(key, Array.prototype.slice.call(args))\n                const result = oldfn.apply(obj, args)\n                this.fout(key, result)\n                return result\n            }\n        }\n        // can't use Object.keys for prototype walking\n        for (let key in obj) {\n            if (typeof obj[key] === \"function\") {\n                wrapkey(obj, key)\n            }\n        }\n        this.log(\"┌ TRACELOG START\")\n    }\n    // called when entering a function\n    fin(fn, args) {\n        this.padding += this.pad\n        this.log(`├─> entering ${fn}`, args)\n    }\n    // called when exiting a function\n    fout(fn, result) {\n        this.log(\"│<──┘ generated return value\", result)\n        this.padding = this.padding.substring(0, this.padding.length - this.pad.length)\n    }\n    // log message formatting\n    format(s, tick) {\n        let nf = function(t) {\n            t = `${t}`\n            while (t.length < 4) {\n                t = `0${t}`\n            }\n            return t\n        }\n        return `${nf(tick)}> ${this.padding}${s}`\n    }\n    // log a trace message\n    log() {\n        let s = Array.prototype.slice.call(arguments)\n        const stringCollapse = function(v) {\n            if (!v) {\n                return \"<falsey>\"\n            }\n            if (typeof v === \"string\") {\n                return v\n            }\n            if (v instanceof HTMLElement) {\n                return v.outerHTML || \"<empty>\"\n            }\n            if (v instanceof Array) {\n                return `[${v.map(stringCollapse).join(\",\")}]`\n            }\n            return v.toString() || v.valueOf() || \"<unknown>\"\n        }\n        s = s.map(stringCollapse).join(\", \")\n        this.messages.push(this.format(s, this.tick++))\n    }\n    // turn the log into a structured string with\n    // unicode box codes to make it a sensible trace.\n    toString() {\n        let cap = \"×   \"\n        let terminator = \"└───\"\n        while (terminator.length <= this.padding.length + this.pad.length) {\n            terminator += cap\n        }\n        let _ = this.padding\n        this.padding = \"\"\n        terminator = this.format(terminator, this.tick)\n        this.padding = _\n        return `${this.messages.join(\"\\n\")}\\n${terminator}`\n    }\n}\n"],"names":["objToNode","objNode","insideSvg","options","let","node","nodeName","document","createTextNode","data","createComment","createElementNS","createElement","attributes","Object","entries","forEach","ref","setAttribute","key","value","childNodes","childNode","appendChild","valueDiffing","checked","selected","getFromRoute","route","slice","length","const","c","splice","applyDiff","tree","diff","newNode","reference","_const","info","preDiffApply","action","addAttribute","name","modifyAttribute","newValue","oldValue","removeAttribute","modifyTextElement","nodeType","textDiff","modifyValue","modifyComment","modifyChecked","modifySelected","replaceElement","parentNode","replaceChild","namespaceURI","relocateGroup","Array","groupLength","map","removeChild","from","index","to","insertBefore","removeElement","addElement","element","removeTextElement","addTextElement","console","log","postDiffApply","applyDOM","diffs","every","swap","obj","p1","p2","tmp","undoDiff","undoDOM","reverse","Diff","this","elementDescriptors","el","output","push","replace","id","findUniqueDescriptors","li","uniqueDescriptors","duplicateDescriptors","descriptor","inUnique","uniqueInBoth","l1","l2","l1Unique","l2Unique","inBoth","keys","removeDone","outerDone","innerDone","valueDone","isEqual","e1","e2","Boolean","e1Attributes","e2Attributes","attribute","roughlyEqual","sameSiblings","preventRecursion","nodeList1","nodeList2","childUniqueDescriptors","cloneObj","JSON","parse","stringify","findCommonSubsets","c1","c2","marked1","marked2","lcsSize","c1Length","c2Length","matches","subsetsSame","some","i","c1Desc","c2Desc","description","c1Index","c1Element","c2Index","c2Element","makeArray","n","v","getGapInformation","t1","t2","stable","gaps1","gaps2","group","subset","endOld","endNew","j","markSubTrees","oldTree","newTree","oldChildren","newChildren","subsets","returnIndex","arguments","item","subsetsAge","toString","setValue","aKey","aValue","DiffTracker","list","getFromVirtualRoute","nodeIndex","applyVirtualDiff","routeInfo","newSubsets","movedNode","splitLength","delete","filter","concat","applyVirtual","nodeToObj","aNode","prototype","call","undefined","type","includes","toLowerCase","add","fn","DiffFinder","t1Node","t2Node","diffcount","foundAll","debug","t1Orig","t2Orig","tracker","init","findDiffs","diffcap","window","diffError","Error","findNextDiff","error","fdiffs","maxDepth","findOuterDiff","filterOuterDiff","findInnerDiff","findValueDiff","attr","attr1","attr2","attrLength","pos","maxChildCount","childNodesLength","childDiffCount","maxChildDiffCount","sort","indexOf","childNodesLengthDifference","subtrees","t1ChildNodes","t2ChildNodes","attemptGroupRelocation","last","Math","max","destinationDifferent","toGroup","similarNode","testI","gapInformation","shortest","min","index2","index1","DEFAULT_OPTIONS","currentValue","expectedValue","preVirtualDiffApply","postVirtualDiffApply","compress","DiffDOM","hasOwnProperty","varNames","varName","apply","undo","TraceLogger","pad","padding","tick","messages","wrapkey","oldfn","fin","args","result","fout","substring","format","s","t","stringCollapse","HTMLElement","outerHTML","join","valueOf","terminator","_"],"mappings":"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"}